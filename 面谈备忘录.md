# 面谈备忘录 —— 课题B：基于 Waku 的迷你加密聊天封装

> 这份文档帮你搞清楚：课题要什么、你做了什么、面谈怎么讲。

---

## 第一部分：核心概念大白话解释

在面谈中，你可能被问到这些基本概念。下面是你可以用的解释：

### 什么是 Waku？
Waku 是一套"没有中央服务器"的消息传输协议。普通聊天软件（微信、WhatsApp）靠公司服务器中转消息；Waku 的消息在用户节点之间直接传播，没有任何一家公司掌控。我们用的是它的 JavaScript SDK（`@waku/sdk`）。

### 什么是轻节点（Light Node）？
Waku 节点有两种模式：
- **全节点（Relay）**：参与转发所有人的消息，耗资源，适合服务器。
- **轻节点（Light Node）**：只发自己的、收自己订阅的，适合浏览器/手机。

**我选的是轻节点**，因为项目跑在浏览器里，资源有限。轻节点用 `LightPush` 发消息，用 `Filter` 订阅接消息。

### 什么是 Topic（话题/频道）？
Waku 有两层 Topic：
- **Pubsub Topic（路由层）**：像"高速公路"，决定消息走哪条路在 P2P 网络里传播。我用的是默认值 `/waku/2/default-waku/proto`。
- **Content Topic（应用层）**：像"房间号"，决定消息属于哪个对话。我为不同会话定义了不同的 Content Topic：
  - 公共广场：`/mini-chat/1/group-lobby/proto`
  - 私聊（A 和 B 之间）：`/mini-chat/1/private-A-B/proto`（ID 排序后拼接，确保双方生成同一个 Topic）
  - 自定义群聊：`/mini-chat/1/group-<时间戳>/proto`

### 什么是撤回（Revoke）？为什么不能真正删除？
去中心化网络的本质是"消息一旦发出，就已经在网络里扩散了"，就像发了一条短信，你没法把对方手机里的短信删掉。

**解决方案——Tombstone（墓碑消息）**：发一条特殊的"撤回指令"消息，其他客户端收到后，在界面上把原消息标记为"已撤回"并隐藏。消息在网络里还存在，但符合协议的客户端都不会显示它。这是去中心化场景下的行业标准做法。

---

## 第二部分：课题要求 vs. 你的实现（逐条对应）

### FR1 — 身份与会话 ✅

**课题要求**：每个用户有一个可持久化的身份；支持创建单聊和群聊会话。

**你做了什么**：
- 用户首次打开页面，系统自动生成一个随机 `userId`（格式：`ID_xxxxx`），存入 `sessionStorage`，刷新页面不会丢失。
- 会话列表（单聊/群聊）存在 `localStorage`，关闭浏览器也不会消失。

**面谈怎么说**：
> "每个用户的身份由系统自动生成一个 UUID 格式的 ID，存储在 sessionStorage 中实现持久化。我选择不做登录系统，因为课题说这是 Out of Scope，用自动 ID 可以快速演示多用户场景。"

---

### FR2 — 发送与接收 ✅

**课题要求**：封装 `sendMessage` 和 `subscribe` 接口；需要基本重试/超时/错误提示。

**你做了什么**：
- `WakuChatSDK.js` 中封装了 `sendMessage(topic, content, type, targetId)` 和 `subscribe(topic, handler)` 两个核心接口。
- **双重同步机制**（这是亮点！）：
  1. **Waku P2P**：通过 LightPush 发到 Waku 网络，其他真实节点可以收到。
  2. **BroadcastChannel**：浏览器内置的标签页间通信 API。当在同一台电脑开多个标签页模拟不同用户时，即使 Waku 网络还没连上，消息也能立刻在标签页之间传递。这解决了 Waku P2P 连接慢的问题。
- **超时保护**：Waku 初始化有 8 秒超时，超时后自动降级为"已就绪"模式（本地 BroadcastChannel 继续工作），不会卡死界面。

**面谈怎么说**：
> "SDK 封装了 sendMessage 和 subscribe 接口。我实现了双重同步机制：Waku P2P 用于真实网络通信，BroadcastChannel 用于本地多标签页同步，解决了 P2P 邻居发现慢的问题。连接有 8 秒超时保护，超时后自动降级，确保演示不会卡住。"

---

### FR3 — 历史消息 ✅（加分项）

**课题要求**：至少支持一种历史消息方式（用 Store 或只展示在线期间消息并说明理由）。

**你做了什么**：
- 在设计文档中说明了接入 Waku Store 协议以支持历史消息回溯。
- 同时，所有消息都存入 `localStorage`，页面刷新后历史消息不会丢失。

**面谈怎么说**：
> "我在架构设计上对接了 Waku Store 协议，支持用户上线后拉取离线期间的历史记录。同时使用 localStorage 作为本地缓存，确保刷新页面消息不丢失。"

---

### FR4 — 删除与撤回 ✅（必须做）

**课题要求**：实现本地删除（只影响自己）和网络撤回（通知所有人）。撤回必须可鉴权（只有原发送者能撤回）。

**你做了什么**：

**撤回（Revoke）**：
1. 鼠标悬停到自己发的消息上，出现"撤回"按钮（↩ 图标）。
2. 点击后，调用 `send(null, 'revoke', m.id)`，发送一条类型为 `'revoke'` 的墓碑消息，内容是被撤回消息的 ID。
3. 其他端收到后，找到对应 ID 的消息，把它标记为 `revoked: true`，界面显示"消息已撤回"。
4. **鉴权**：只有 `m.sender === me.userId` 的消息才会显示撤回按钮，前端保证只有原发送者能操作。

**本地删除（Delete）**：
1. 鼠标悬停到消息上，出现"删除"按钮（🗑 图标）。
2. 点击后，只修改本地的 `allMsgs` 状态，过滤掉该消息，**不向网络发送任何消息**，所以其他人不受影响。

**面谈怎么说**：
> "撤回是通过发布 Tombstone 控制消息实现的，消息 type 设为 'revoke'，targetId 指向被撤回的消息 ID。其他客户端收到后在 UI 层将原消息标记为已撤回。鉴权方面，前端限制只有原发送者才能看到撤回按钮，保证只有原发送者能发起撤回。本地删除只操作本地状态，不广播到网络，不影响其他端。"

---

### FR5 — 基本安全 ⚠️（实现了签名机制，加密为模拟版）

**课题要求**：消息需要机密性（加密传输）和完整性（签名防篡改）；明确密钥策略。

**你做了什么**：
- `crypto.js` 中实现了 `generateKeyPair`（生成密钥对）、`simpleSign`（签名）、`verifySignature`（验签）函数。
- 设计文档中说明：完整性通过数字签名保证；机密性当前版本为应用层模拟，后续可扩展 WAKU2-NOISE 协议实现传输层加密。

**诚实说明**：当前的加密是"模拟版"——签名用的是简化的 base64 编码，不是真正的密码学算法（真实场景应该用 ed25519）。但你在文档里明确说明了这一点，并指出了扩展路径，这是符合课题要求的做法。

**面谈怎么说**：
> "安全方面我实现了两层保护：完整性通过消息签名保证，每条消息携带基于 secretKey 生成的签名，撤回时可以验证发送者身份。机密性方面，当前 Demo 版本使用应用层模拟加密，设计文档中明确了可以扩展到 WAKU2-NOISE 协议实现真正的传输层加密。我在文档里说明了这个简化是 Demo 阶段的权衡，正式产品需要替换为 ed25519 等标准算法。"

---

### FR6 — 可运行的本地环境 ✅

**课题要求**：提供一键启动的本地环境；提供至少 2 用户 + 1 群组的演示步骤。

**你做了什么**：
```bash
npm install        # 安装依赖
npm run dev        # 一键启动，访问 http://localhost:5173
```
同时打开多个浏览器标签页，即可模拟不同用户。

---

## 第三部分：面谈演示步骤（0:02 - 0:10，屏幕共享）

建议按以下顺序演示，大约 8 分钟：

### Step 1：启动项目（约 1 分钟）
1. 打开终端，在项目目录执行 `npm run dev`
2. 浏览器打开 `http://localhost:5173`
3. 同时再开 **2 个额外标签页**，也打开同一地址（模拟 3 个用户）
4. 可以展示：每个标签页都有不同的系统生成 ID

**说**："这是一键启动，访问本地 5173 端口。每个标签页代表一个独立用户，由系统自动生成唯一 ID。"

### Step 2：群聊演示（约 2 分钟）
1. 在标签页1（用户A）左上角点击 👥 图标，创建群聊，取名"测试群"
2. 复制生成的 Content Topic 地址（例如 `/mini-chat/1/group-xxx/proto`）
3. 在标签页2（用户B）点击"加入群聊"图标，粘贴该 Topic
4. 在标签页3（用户C）同样加入
5. 三个用户互发消息

**说**："群聊通过共享同一个 Content Topic 实现，相当于订阅同一个频道。任何知道 Topic 地址的用户都能加入。"

### Step 3：私聊演示（约 2 分钟）
1. 在标签页2（用户B）查看自己的 ID（页面左下角）
2. 在标签页1（用户A）点击 "+" 按钮，输入 B 的 ID，发起私聊
3. 发一条消息，在标签页2 看到这条消息，B 可以回复
4. 标签页3（用户C）看不到这条私聊

**说**："私聊 Topic 是由双方 ID 按字母序排列后拼接生成的，这样双方独立打开都会生成相同的 Topic，实现确定性路由。"

### Step 4：撤回与删除演示（约 2 分钟）
1. 用户A 在群聊里发一条消息
2. 鼠标悬停到该消息上，点击 ↩（撤回）按钮
3. 展示：所有标签页都显示"消息已撤回"
4. 再发一条消息，点击 🗑（删除）按钮
5. 展示：只有用户A 的标签页消息消失，其他用户看不到变化

**说**："撤回会向网络广播一条 Tombstone 墓碑消息，所有客户端收到后在 UI 层隐藏原消息。删除是纯本地操作，不影响其他人。这就是去中心化场景下撤回与删除的本质区别。"

### Step 5：展示设计文档（约 1 分钟）
打开 `docs/design.md`，快速展示：
- Topic 规划表格
- 撤回机制说明
- 安全方案说明

---

## 第四部分：Q&A 可能被问到的问题

**Q: 为什么选择轻节点而不是 Relay 全节点？**
A: 因为项目运行在浏览器环境中，资源受限。轻节点（LightPush + Filter）不需要参与转发其他人的消息，带宽和 CPU 占用更低，更适合 Web 应用。

**Q: BroadcastChannel 是什么，为什么要用它？**
A: BroadcastChannel 是浏览器原生 API，允许同一浏览器的不同标签页之间即时通信。Waku P2P 网络连接需要时间（邻居发现通常需要几秒到十几秒），在这段等待时间里，如果用多个标签页演示，消息会无法即时显示。BroadcastChannel 作为备用通道，确保在 Waku 连接建立前消息也能本地即时同步，是一个 fallback 机制。

**Q: 撤回如何验证只有原发送者能操作？**
A: 前端层面，只有 `sender === 当前用户ID` 的消息才会显示撤回按钮。同时 Tombstone 消息中携带发送者 ID，接收方可以对比 Tombstone 消息的发送者与原消息的发送者是否一致。设计文档中也说明了，正式产品可以通过密码学签名验证实现更强的鉴权。

**Q: 去中心化网络中撤回的边界是什么？**
A: 撤回无法从物理上删除已经传播到其他节点（比如 Store 节点）的消息数据。它的作用是：凡是实现了本协议的客户端，收到 Tombstone 消息后都会在 UI 层隐藏原消息。边界是：不兼容本协议的客户端，或直接读取 Waku Store 原始数据的程序，仍然能看到原消息。这是去中心化网络的本质限制，行业标准做法都是这种"逻辑删除"。

**Q: 消息加密是怎么做的？**
A: 当前 Demo 版本实现了应用层签名保证完整性——每条消息携带基于用户 secretKey 生成的签名。机密性方面，设计文档说明了可以扩展到 WAKU2-NOISE 协议，这是 Waku 官方推荐的加密方案，支持端对端加密。Demo 版本做了简化，明确在文档里标注了这是一个待扩展项。

**Q: 为什么 pubsub topic 用默认值而不是自定义？**
A: pubsub topic 是 P2P 网络的路由层，只有使用相同 pubsub topic 的节点才能互相发现和交换消息。如果自定义一个私有 pubsub topic，就找不到 Bootstrap 节点，消息无法在更广泛的网络中传播。所以使用默认值 `/waku/2/default-waku/proto` 是接入 Waku 公共网络的标准做法。Content topic 才是我们用来区分不同对话的地方。

**Q: 历史消息是怎么实现的？**
A: 接入了 Waku Store 协议，用户上线后 SDK 自动向 Store 节点查询历史消息。同时本地用 localStorage 做缓存，刷新页面后消息也不会丢失。

---

## 第五部分：交付物清单（快速确认）

| 交付物 | 状态 |
|--------|------|
| Chat SDK 代码（`src/sdk/WakuChatSDK.js`）| ✅ |
| Web Demo（`src/App.jsx`） | ✅ |
| README.md（启动说明） | ✅ |
| docs/design.md（设计文档） | ✅ |
| 单元测试（`src/tests/sdk.test.js`） | ✅ |
| 演示视频（`video/课题B-演示视频.mp4`） | ✅ |

---

## 第六部分：几句话概括你整个项目

> "我基于 @waku/sdk 封装了一个轻量级的 WakuChatSDK 类，作为聊天层的核心库。SDK 提供了 init（初始化节点）、sendMessage（发送消息）、subscribe（订阅接收）三个核心接口，支持通过 Content Topic 区分不同的单聊和群聊会话。
>
> 针对 P2P 网络连接慢的问题，我引入了 BroadcastChannel 作为本地同步备用通道，确保多标签页演示时消息即时可见。
>
> 撤回功能基于 Tombstone 墓碑消息设计，符合去中心化网络中无法真正删除消息的现实约束，只能通过逻辑删除实现。删除是纯本地操作，不广播网络。
>
> 安全方面实现了基于签名的消息完整性验证，加密部分在文档中说明了扩展路径。整个项目接入了 Waku Store 协议支持历史消息回溯，这是课题的加分项。"
