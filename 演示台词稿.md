# 演示台词稿（面谈用）
> 照着这个说就行，不需要记住所有细节，这是你自己做的东西，描述一下你看到的就好。

---

## 开场（0:02 开始，约 30 秒）

> "我这次做的是课题 B，基于 Waku 封装一个聊天 SDK，然后做了一个可以跑的 Web Demo。
> 我先给你们演示一下功能，然后我们可以深入聊设计思路。
> 我现在打开项目。"

打开终端，输入：
```
npm run dev
```

然后打开浏览器，访问 http://localhost:5173

---

## 第一步：介绍界面（约 1 分钟）

打开页面后，说：

> "这是 Demo 的主界面。左边是会话列表，右边是聊天区域。
> 页面左下角可以看到我的用户 ID，是系统自动生成的，比如 ID_ab3k9 这样的格式，存在浏览器里，刷新页面也不会变。
> 这对应课题 FR1 的身份持久化要求。"

然后再新开两个标签页，也打开同一个地址，说：

> "我现在开三个标签页来模拟三个用户，每个标签页的 ID 都是不同的。"

---

## 第二步：演示群聊（约 2 分钟）

在**标签页1（用户A）**，点左上角的 👥 图标（创建群聊），取名叫"测试群"，点确认。

说：
> "我创建了一个群聊，叫测试群。系统给这个群分配了一个唯一的频道地址，叫 Content Topic。
> 相当于这个群有一个'房间号'，任何知道这个房间号的人都可以加入。"

把 Content Topic 地址复制下来（界面里能看到，格式类似 `/mini-chat/1/group-xxx/proto`）。

在**标签页2（用户B）**，点 LogIn 图标（加入群聊），粘贴刚才复制的 Topic。

在**标签页3（用户C）**，同样操作加入群聊。

然后三个标签页互发几条消息，说：

> "三个用户都在同一个群里，互发消息，都能看到。这是 FR2 的发送接收功能，也满足 FR1 的群聊要求。"

---

## 第三步：演示私聊（约 2 分钟）

在**标签页2（用户B）**，看一下左下角的 ID，比如是 `ID_xyz12`。

在**标签页1（用户A）**，点左上角的 "+" 按钮，输入 B 的 ID：`ID_xyz12`，点确认。

说：
> "私聊是通过输入对方的 ID 发起的。系统会把我的 ID 和对方的 ID 拼在一起，生成一个唯一的私聊频道地址。
> 这样设计的好处是：双方各自打开都会生成同一个地址，不需要服务器来协调。"

发一条消息，在标签页2可以看到这条消息，B 可以回复。

然后看标签页3，说：
> "标签页3（用户C）看不到这条私聊，因为 C 没有订阅这个频道。"

---

## 第四步：演示撤回（最重要！约 2 分钟）

在**标签页1（用户A）**的群聊里发一条消息，比如"这是一条要被撤回的消息"。

确认三个标签页都能看到这条消息后，说：

> "现在三个人都看到这条消息了。我来演示撤回。"

鼠标**停在那条消息上**，出现小按钮，点 ↩（撤回按钮）。

切换到标签页2和标签页3，展示那条消息变成了"消息已撤回"，说：

> "撤回的原理是这样的：我不是真的删掉了网络里的消息——在去中心化网络里，消息一旦发出就无法从所有节点删除。
> 我做的是发了一条特殊消息到网络里，叫 Tombstone，就是墓碑消息。它的意思是'请把 ID 为 xxx 的消息标记为已撤回'。
> 所有客户端收到这条指令后，就把原消息在界面上替换成'消息已撤回'。
> 这是去中心化聊天场景下的标准做法。"

然后说：
> "撤回按钮只有在自己发的消息上才会出现，别人发的消息我没有权限撤回。这就是鉴权。"

---

## 第五步：演示本地删除（约 1 分钟）

再发一条消息，鼠标停在上面，点 🗑（删除按钮）。

展示：标签页1这条消息消失了，切换到标签页2和3，那条消息还在，说：

> "删除只是本地删除，不会发任何通知到网络上，其他人的界面完全不受影响。
> 这和撤回是两种完全不同的行为：撤回是告诉所有人，删除只是我自己不想看。"

---

## 第六步：展示设计文档（约 1 分钟）

打开 `docs/design.md` 文件，说：

> "我在设计文档里说明了几个关键设计决策：
>
> 第一，为什么用轻节点而不是全节点：因为项目跑在浏览器里，资源有限，轻节点的 LightPush 和 Filter 模式更适合。
>
> 第二，Topic 规划：Waku 有两层 Topic，Pubsub Topic 是路由层，就像快递走的高速公路；Content Topic 是应用层，就是具体的房间号。我给不同的对话场景规划了不同的 Content Topic 格式。
>
> 第三，撤回和删除的边界说明：文档里写明了撤回无法保证从所有物理节点删除数据，只能在协议兼容的客户端上实现逻辑隐藏。"

---

## 回答问题时的关键句子

**如果被问"Waku 的 Topic 是什么"：**
> "Waku 有两层 Topic。Pubsub Topic 是消息在 P2P 网络里路由的路径，我用的是默认值，这样能接入公共的 Waku 网络。Content Topic 是应用层的频道地址，我用它区分不同的对话，比如私聊有专属地址、群聊有专属地址。"

**如果被问"为什么用轻节点"：**
> "全节点需要参与转发所有人的消息，在浏览器里资源消耗太大。轻节点只发自己的、收自己订阅的，更适合 Web 应用场景。"

**如果被问"加密是怎么做的"：**
> "我实现了签名机制来保证消息完整性，确保消息没有被篡改，也能验证发送者身份。加密传输这部分在 Demo 里做了简化处理，设计文档里说明了后续可以对接 Waku 的 NOISE 协议做真正的端对端加密，这是一个明确的待扩展项。"

**如果被问"撤回为什么不能真正删除"：**
> "去中心化网络里，消息发出去之后就已经传播到很多个节点上了，就像你发了一条短信，没有办法把对方手机里的短信删掉。能做到的是发一条撤回指令，告诉所有兼容这个协议的客户端，在界面上把这条消息隐藏掉。数据在网络底层可能还存在，但界面上就不显示了。"

**如果被问"BroadcastChannel 是什么"：**
> "BroadcastChannel 是浏览器自带的一个功能，可以让同一个浏览器的不同标签页之间互相传消息。我用它做了一个备用通道：Waku 网络连接需要时间，在等待期间，多标签页之间的消息可以通过 BroadcastChannel 立刻同步，不会出现发了消息对方看不到的情况。"

---

## 如果被问到测试

> "测试文件里覆盖了消息格式验证和撤回逻辑的结构测试。加密部分的测试函数因为接口有调整，需要同步更新，是一个待修复的小问题。"

然后换个话题，不要继续深究。

---

## 总结话术（结束展示时说）

> "整个项目我封装了一个 WakuChatSDK 类，对外暴露 init、sendMessage、subscribe 三个核心接口，隐藏了 Waku 底层的复杂性。在这个 SDK 基础上，我实现了单聊、群聊、撤回、删除完整的 Web Demo，并且加了 BroadcastChannel 双通道机制解决演示时的即时性问题。设计文档里说明了所有的关键决策和边界。"
